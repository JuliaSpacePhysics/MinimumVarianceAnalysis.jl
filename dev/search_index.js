var documenterSearchIndex = {"docs":
[{"location":"#MinimumVarianceAnalysis","page":"Home","title":"MinimumVarianceAnalysis","text":"(Image: DOI) (Image: version)\n\nA Julia package for minimum or maximum variance analysis (MVA).\n\n[x] Maximum Variance Analysis on Magnetic Field (MVAB)\n[x] Maximum Variance Analysis on Electric Field (MVAE)","category":"section"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"Error estimates for MVA:","category":"section"},{"location":"#Validation-with-PySPEDAS","page":"Home","title":"Validation with PySPEDAS","text":"References: mva_eigen, test_minvar.py - PySPEDAS\n\nusing MinimumVarianceAnalysis\nusing PySPEDAS\nusing PySPEDAS.PythonCall\n@py import pyspedas.cotrans_tools.tests.test_minvar: TestMinvar\n@py import pyspedas.cotrans_tools.minvar_matrix_make: minvar_matrix_make\n\nisapprox_eigenvector(v1, v2) = isapprox(v1, v2) || isapprox(v1, -v2)\n\npytest = TestMinvar()\npytest.setUpClass()\n\nthb_fgs_gsm = get_data(\"idl_thb_fgs_gsm_mvaclipped1\")\njl_mva_eigen = mva_eigen(thb_fgs_gsm)\njl_mva_mat = jl_mva_eigen.vectors\njl_mva_vals = jl_mva_eigen.values\n\npy_mva_vals = PyArray(pytest.vals.y) |> vec\npy_mva_mat = PyArray(pytest.mat.y[0])'\n@assert isapprox(jl_mva_vals, py_mva_vals)\n@assert all(isapprox_eigenvector.(eachcol(jl_mva_mat), eachcol(py_mva_mat)))\n\nSince eigenvectors are only unique up to sign; therefore, the test checks if each Julia eigenvector is approximately equal to the corresponding Python eigenvector or its negative.","category":"section"},{"location":"#Benchmark","page":"Home","title":"Benchmark","text":"using Chairmarks\n@b mva_eigen(thb_fgs_gsm), minvar_matrix_make(\"idl_thb_fgs_gsm_mvaclipped1\")\n\nJulia demonstrates a performance advantage of approximately 1000 times over Python, with significantly reduced memory allocations.  Moreover, Julia's implementation is generalized for N-dimensional data.","category":"section"},{"location":"#MinimumVarianceAnalysis.B_x3_error-NTuple{8, Any}","page":"Home","title":"MinimumVarianceAnalysis.B_x3_error","text":"Calculate the composite statistical error estimate for ⟨B·x₃⟩: |Δ⟨B·x₃⟩| = √(λ₃/(M-1) + (Δφ₃₂⟨B⟩·x₂)² + (Δφ₃₁⟨B⟩·x₁)²)\n\nParameters:\n\nλ₁, λ₂, λ₃: eigenvalues in descending order\nM: number of samples\nB: mean magnetic field vector\nx₁, x₂, x₃: eigenvectors\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.E_x1_error-NTuple{8, Any}","page":"Home","title":"MinimumVarianceAnalysis.E_x1_error","text":"E_x1_error(λ₁, λ₂, λ₃, M, E, x₁, x₂, x₃)\n\nCalculate the composite statistical error estimate for ⟨E·x₁⟩ (the mean electric field along the maximum variance / normal direction):\n\nΔmathbfEmathbfx_1 = sqrtfracλ_1M-1 + (Δφ_12mathbfEmathbfx_2)^2 + (Δφ_13mathbfEmathbfx_3)^2\n\nParameters:\n\nλ₁, λ₂, λ₃: eigenvalues in descending order\nM: number of samples\nE: mean electric field vector\nx₁, x₂, x₃: eigenvectors\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.check_mva_eigen-Tuple{Any}","page":"Home","title":"MinimumVarianceAnalysis.check_mva_eigen","text":"check_mva_eigen(F; r0=5, verbose=false, field = :B)\n\nCheck the quality of the MVA result.\n\nIf λ₁ ≥ λ₂ ≥ λ₃ are 3 eigenvalues of the constructed matrix M. For MVAB, a good indicator of nice results should have abs(λ₂  λ₃)  r0 (default r0 = 5).\n\nFor MVAE, a reliable normal direction requires the maximum eigenvalue λ₁ to be well-separated from the intermediate eigenvalue λ₂. The ratio λ₁  λ₂  r0 is used as a quality indicator.\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.convection_efield-Tuple{Any, Any}","page":"Home","title":"MinimumVarianceAnalysis.convection_efield","text":"convection_efield(v, B; dim=nothing)\n\nCompute the convection electric field mathbfE = -mathbfv  mathbfB from plasma velocity v and magnetic field B.\n\nThis can be used as a proxy for the measured electric field when direct measurements are unavailable.\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.mva","page":"Home","title":"MinimumVarianceAnalysis.mva","text":"mva(V, F=V; dim=nothing, kwargs...)\n\nTransform a timeseries V into the LMN coordinate system based on the minimum/maximum variance analysis of reference field F along the dim dimension (time).\n\nSee also: mva_eigen, transform\n\n\n\n\n\n","category":"function"},{"location":"#MinimumVarianceAnalysis.mva_eigen-Tuple{Any}","page":"Home","title":"MinimumVarianceAnalysis.mva_eigen","text":"mva_eigen(x::AbstractMatrix; dim = nothing, sort=(;), check=false) -> F::Eigen\n\nPerform minimum variance analysis of the magnetic field B or maximum variance analysis of the electric field E when field=:E.\n\nx varies along the dim dimension.\n\nReturn Eigen factorization object F which contains the eigenvalues in F.values and the eigenvectors in the columns of the matrix F.vectors. The kth eigenvector can be obtained from the slice F.vectors[:, k].\n\nSet check=true to check the reliability of the result.\n\nNotes\n\nFor a one-dimensional current layer, the tangential electric field components are approximately constant across the boundary, while the normal component exhibits the largest variation. Therefore, the eigenvector corresponding to the maximum eigenvalue λ_1 (first column of F.vectors) gives an estimate of the boundary normal direction.\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.normal-Tuple{LinearAlgebra.Eigen}","page":"Home","title":"MinimumVarianceAnalysis.normal","text":"normal(F::Eigen; field=:B)\n\nReturn the boundary normal eigenvector from an MVA result.\n\nfield=:B (MVAB): minimum variance direction (last eigenvector)\nfield=:E (MVAE): maximum variance direction (first eigenvector)\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.transform-Tuple{Any, AbstractMatrix}","page":"Home","title":"MinimumVarianceAnalysis.transform","text":"transform(A, mat::AbstractMatrix; dim=nothing, query=nothing)\n\nTransform A into a new coordinate system using transformation matrix mat along the dim dimension (time).\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.Δφij-NTuple{4, Any}","page":"Home","title":"MinimumVarianceAnalysis.Δφij","text":"Δφij(λᵢ, λⱼ, λ₃, M)\n\nCalculate the phase error between components i and j according to: |Δφᵢⱼ| = |Δφⱼᵢ| = √(λ₃/(M-1) * (λᵢ + λⱼ - λ₃)/(λᵢ - λⱼ)²)\n\nParameters:\n\nλᵢ: eigenvalue i\nλⱼ: eigenvalue j\nλ₃: smallest eigenvalue (λ₃)\nM: number of samples\n\n\n\n\n\n","category":"method"},{"location":"#MinimumVarianceAnalysis.Δφij-index","page":"Home","title":"MinimumVarianceAnalysis.Δφij","text":"Δφij(λᵢ, λⱼ, λ₃, M)\n\nCalculate the phase error between components i and j according to: |Δφᵢⱼ| = |Δφⱼᵢ| = √(λ₃/(M-1) * (λᵢ + λⱼ - λ₃)/(λᵢ - λⱼ)²)\n\nParameters:\n\nλᵢ: eigenvalue i\nλⱼ: eigenvalue j\nλ₃: smallest eigenvalue (λ₃)\nM: number of samples\n\n\n\n\n\n","category":"function"},{"location":"#MinimumVarianceAnalysis.B_x3_error-index","page":"Home","title":"MinimumVarianceAnalysis.B_x3_error","text":"Calculate the composite statistical error estimate for ⟨B·x₃⟩: |Δ⟨B·x₃⟩| = √(λ₃/(M-1) + (Δφ₃₂⟨B⟩·x₂)² + (Δφ₃₁⟨B⟩·x₁)²)\n\nParameters:\n\nλ₁, λ₂, λ₃: eigenvalues in descending order\nM: number of samples\nB: mean magnetic field vector\nx₁, x₂, x₃: eigenvectors\n\n\n\n\n\n","category":"function"},{"location":"#MinimumVarianceAnalysis.E_x1_error-index","page":"Home","title":"MinimumVarianceAnalysis.E_x1_error","text":"E_x1_error(λ₁, λ₂, λ₃, M, E, x₁, x₂, x₃)\n\nCalculate the composite statistical error estimate for ⟨E·x₁⟩ (the mean electric field along the maximum variance / normal direction):\n\nΔmathbfEmathbfx_1 = sqrtfracλ_1M-1 + (Δφ_12mathbfEmathbfx_2)^2 + (Δφ_13mathbfEmathbfx_3)^2\n\nParameters:\n\nλ₁, λ₂, λ₃: eigenvalues in descending order\nM: number of samples\nE: mean electric field vector\nx₁, x₂, x₃: eigenvectors\n\n\n\n\n\n","category":"function"}]
}
